#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

// lexer

void fileChecker(char str[]);
void getLexeme();
bool isSeparator(char ch);
bool isOperator(char ch);
void identifyOperator(char *subStr);
void identifyDelimiter(char ch);
bool isIdentifierElement(char ch);
bool isKeyword(char *subStr);
bool isReservedword(char *subStr);
bool isNoiseword(char *subStr);
bool isIntegerLiteral(char *str);
bool isFloatLiteral(char *str);
bool isIdentifier(char *str);

char *token;
FILE *outputptr;
FILE *inputptr;

int i;
char ch1 = ' ';
char ch2 = ' ';
char comment[1000];
char charLit[100];
char strLit[100];
char operators[100];
char string[1000];
int strIndex = 0;

// parser

void parse();
void getToken();
void stmt();
void scan_stmt();
void print_stmt();
void declaration_stmt();
void assignment_stmt();
void arith_expr();
void arith_term();
void arith_power();
void arith_factor();
void iterative_stmt();
void iterative_assign_stmt();
void declaration_assign_stmt();
void condition();
void increment();
void conditional_stmt();
void bool_expr();
void bool_term();
void bool_factor();
void rel_expr();
void rel_op();
void error(char *token, char *delimiter);
void error_recovery(char *delimiter);

FILE *fptr;

char currentLexeme[100];
char currentToken[20];


int main()
{
    char filepath[100];
    printf("Input filepath: ");
    scanf("%s", filepath);
    fileChecker(filepath);

    // lexer

    if(inputptr == NULL)
        return 0;
    else
        getLexeme();

    fclose(outputptr);
    fclose(inputptr);

    // parser

    fptr = fopen("SymbolTable.txt", "r");
    if (fptr == NULL)
        printf("Error! opening file");
    else
        parse();

    fclose(fptr);

    return (0);
}

void fileChecker(char str[])
{
    int len = strlen(str);
    int checker = 0;

    // check if the file path have proper length
    if (len <= 1)
        printf("Invalid file path\n");
    // check file extension
    else if (str[len - 1] == 's' && str[len - 2] == '.')
    {
        inputptr = fopen(str, "r");
        outputptr = fopen("SymbolTable.txt", "w");
        checker = 1;
        if (inputptr == NULL)
            printf("\nFile doesn't exist\n");
    }
    else if (len > 1 && checker != 1)
        printf("Invalid file extension\n.\n.\nProgram will now close");
}

void getLexeme()
{
    do
    {
        // Comment
        if(ch1 == '/' && ch2 == '*')
        {
            // get two characters to determine the end comment: */
            ch1 = fgetc(inputptr);
            ch2 = fgetc(inputptr);
            i=0;

            // store character in ch1 to comment array if ch1 and ch2 do not form end comment symbols
            while(!feof(inputptr))
            {
                if(ch1 == '*' && ch2 == '/')
                {
                    comment[i] = '\0';
                    fprintf(outputptr, "%s\t\t\t\t\t\t\t\tcomment\n", comment);
                    ch1 = fgetc(inputptr);
                    ch2 = fgetc(inputptr);
                    break;
                }
                else
                {
                    comment[i] = ch1;
                    i++;
                    ch1 = ch2;
                    ch2 = fgetc(inputptr);
                }
            }
        }

        // Character Literal
        else if(ch1 == '\'')
        {
            ch1 = ch2;
            ch2 = fgetc(inputptr);

            // if character is '' or empty character literal
            if(ch1 == '\'')
            {
                fprintf(outputptr, "\t\t\t\t\t\t\t\tinvalid\n");
                ch1 = ch2;
                ch2 = fgetc(inputptr);
            }

            // if '\''
            else if(ch1 == '\\' && ch2 == '\'')
            {
                fprintf(outputptr, "%c\t\t\t\t\t\t\t\tchar_const\n", ch2);
                fgetc(inputptr);
                ch1 = fgetc(inputptr);
                ch2 = fgetc(inputptr);
            }

            // if '\\'
            else if(ch1 == '\\' && ch2 == '\\')
            {
                fprintf(outputptr, "%c\t\t\t\t\t\t\t\tchar_const\n", ch2);
                fgetc(inputptr);
                ch1 = fgetc(inputptr);
                ch2 = fgetc(inputptr);
            }

            // if 'abc'
            else if(ch2 != '\'')
            {
                i = 0;
                charLit[i] = ch1;
                i++;
                charLit[i] = ch2;
                i++;
                ch1 = fgetc(inputptr);

                while(!feof(inputptr))
                {
                    if(ch1 == '\'')
                    {
                        charLit[i] = '\0';
                        fprintf(outputptr, "%s\t\t\t\t\t\t\t\tinvalid\n", charLit);
                        ch1 = fgetc(inputptr);
                        ch2 = fgetc(inputptr);
                        break;
                    }
                    else
                    {
                        charLit[i] = ch1;
                        i++;
                        ch1 = fgetc(inputptr);
                    }
                }
            }

            // if valid character literal
            else
            {
                fprintf(outputptr, "%c\t\t\t\t\t\t\t\tchar_const\n", ch1);
                ch1 = fgetc(inputptr);
                ch2 = fgetc(inputptr);
            }
        }

        // String Literal
        else if(ch1 == '\"')
        {
            ch1 = ch2;
            i=0;

            // get all string literal inside " "
            while (!feof(inputptr))
            {
                ch2 = fgetc(inputptr);
                if (ch1 == '\"')
                {
                    strLit[i] = '\0';
                    ch1 = ch2;
                    ch2 = fgetc(inputptr);
                    fprintf(outputptr, "%s\t\t\t\t\t\t\t\tstr_const\n", strLit);
                    break;
                }
                else if (ch1 == '\\' && ch2 == '\"')
                {
                    strLit[i] = '\"';
                    i++;
                    ch1 = fgetc(inputptr);
                }
                else if (ch1 == '\\' && ch2 == '\\')
                {
                    strLit[i] = '\\';
                    i++;
                    ch1 = fgetc(inputptr);
                }
                else
                {
                    strLit[i] = ch1;
                    i++;
                    ch1 = ch2;
                }
            }
        }

        // Special Character
        else if (ch1 == '&')
        {
            fprintf(outputptr, "%c\t\t\t\t\t\t\t\t&\n", ch1);
            ch1 = ch2;
            ch2 = fgetc(inputptr);
        }

        // Format Specifier
        else if(ch1 == '%' && (ch2 == 'd' || ch2 == 'f' || ch2 == 'c' || ch2 == 's'))
        {
            fprintf(outputptr, "%c%c\t\t\t\t\t\t\t\tid_symbol\n", ch1,ch2);
            ch1 = fgetc(inputptr);
            ch2 = fgetc(inputptr);
        }

        else if(isSeparator(ch1) == false)
        {
            string[strIndex] = ch1;
            strIndex++;
            ch1 = ch2;
            ch2 = fgetc(inputptr);
        }

        else if(isSeparator(ch1) == true && strIndex == 0)
        {
            // Operator
            if(isOperator(ch1))
            {
                i = 0;
                while(isOperator(ch1))
                {
                    operators[i] = ch1;
                    i++;
                    ch1 = ch2;
                    ch2 = fgetc(inputptr);
                }
                operators[i] = '\0';
                identifyOperator(operators);
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", operators, token);
            }

            // Delimiter
            else
            {
                if(ch1 != ' ' && ch1 != '\n')
                {
                    identifyDelimiter(ch1);
                    fprintf(outputptr, "%c\t\t\t\t\t\t\t\t%s\n", ch1, token);
                }
                ch1 = ch2;
                ch2 = fgetc(inputptr);
            }
        }

        else if(isSeparator(ch1) == true && strIndex > 0)
        {
            string[strIndex] = '\0';

            if(isKeyword(string) == true)
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", string, token);
            }
            else if(isReservedword(string) == true)
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", string, token);
            }
            else if(isNoiseword(string) == true)
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", string, token);
            }
            else if(isIntegerLiteral(string) == true)
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", string, token);
            }
            else if(isFloatLiteral(string) == true)
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", string, token);
            }
            else if(isIdentifier(string) == true)
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\t%s\n", string, token);
            }
            else
            {
                fprintf(outputptr, "%s\t\t\t\t\t\t\t\tinvalid\n", string);
            }

            strIndex = 0;
        }

        else
        {
            ch1 = ch2;
            ch2 = fgetc(inputptr);
        }

    }
    while(!feof(inputptr));

}

void parse(){
    getToken();
    do{
       stmt();
    }
    while(!feof(fptr));
}

void getToken()
{
    char ch = fgetc(fptr);

    // gets the lexeme
    i = 0;
    while (ch != '\t')
    {
        currentLexeme[i] = ch;
        i++;
        ch = fgetc(fptr);
    }
    currentLexeme[i] = '\0';

    // skips all \t
    while (ch == '\t')
    {
        ch = fgetc(fptr);
    }

    // gets the token
    i = 0;
    while (ch != '\n')
    {
        currentToken[i] = ch;
        i++;
        ch = fgetc(fptr);
    }
    currentToken[i] = '\0';

    // skips comment
    if(strcmp(currentToken,"comment") == 0){
        getToken();
    }
    else{
        printf("Lexeme: %s\t", currentLexeme);
        printf("Token: %s\n", currentToken);
    }
}

void stmt(){
    scan_stmt();
    print_stmt();
    declaration_stmt();
    assignment_stmt();
    iterative_stmt();
    conditional_stmt();
}

void scan_stmt(){
    if(strcmp(currentToken,"scanf_keyword") != 0)  // escan
        return;
    else{
        printf("Enter <scan_stmt>\n");
        getToken();
        if(strcmp(currentToken,"(") != 0) // (
            error("(",":");
        else{
            getToken();
            if(strcmp(currentToken,"id_symbol") != 0) //id_symbol
                error("id_symbol",":");
            else{
                getToken();
                if(strcmp(currentToken,",") != 0) // ,
                    error(",",":");
                else{
                    getToken();
                    if(strcmp(currentToken,"&") != 0) // &
                        error("&",":");
                    else{
                        getToken();
                        if(strcmp(currentToken,"identifier") != 0) // id
                            error("identifier",":");
                        else{
                            getToken();
                            if(strcmp(currentToken,")") != 0)  // )
                                error(")",":");
                            else{
                                getToken();
                                if(strcmp(currentToken,":") != 0)  // :
                                    error(":","proceed");
                                else{
                                    printf("Exit <scan_stmt>\n");
                                    getToken();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void print_stmt(){
    if(strcmp(currentToken,"printf_keyword") != 0) // print
        return;
    else{
        printf("Enter <print_stmt>\n");
        getToken();
        if(strcmp(currentToken,"(") != 0) // (
            error("(",":");
        else{
            getToken();
            if(strcmp(currentToken,"str_const") == 0){  // str_const
                getToken();
                if(currentToken[0] == ','){  // ,
                    getToken();
                    if(strcmp(currentToken,"id_symbol") != 0) // id_symbol
                        error("id_symbol",":");
                    else{
                        getToken();
                        if(currentToken[0] != ',') // ,
                            error(",",":");
                        else{
                            getToken();
                            if(strcmp(currentToken,"identifier") != 0) // identifier
                                error("identifier",":");
                            else{
                                getToken();
                                if (currentToken[0] != ')') // )
                                    error(")",":");
                                else{
                                    getToken();
                                    if(currentToken[0] != ':') // :
                                        error(":","proceed");
                                    else{
                                        printf("Exit <print_stmt>\n");
                                        getToken();
                                    }
                                }
                            }
                        }
                    }
                }
                else if(currentToken[0] == ')'){ // )
                    getToken();
                    if(currentToken[0] != ':') // :
                        error(":","proceed");
                    else{
                        printf("Exit <print_stmt>\n");
                        getToken();
                    }
                }
                else
                    error(", or )",":");
            } // end str_const
            else if(strcmp(currentToken,"id_symbol") == 0){  // id_symbol
                getToken();
                if(currentToken[0] != ',')  // ,
                    error(",",":");
                else{
                    getToken();
                    if(strcmp(currentToken,"identifier") != 0) // identifier
                        error("identifier",":");
                    else{
                        getToken();
                        if (strcmp(currentToken,")") != 0) // )
                            error(")",":");
                        else{
                            getToken();
                            if(strcmp(currentToken,":") != 0) // :
                                error(":","proceed");
                            else{
                                printf("Exit <print_stmt>\n");
                                getToken();
                            }
                        }
                    }
                }
            }
            else
                error("str_const or id_symbol",":");
        }
    }
}

void declaration_stmt(){
    if(strcmp(currentToken,"data_type") != 0) // data type
        return;
    else{
        printf("Enter <declaration_stmt>\n");
        getToken();
        if(strcmp(currentToken,"identifier") != 0)  // id
            error("identifier",":");
        else{
            getToken();
            if(currentToken[0] == ':'){  // :
                printf("Exit <declaration_stmt>\n");
                getToken();
            }
            else if(currentToken[0] == ','){ // ,
                while(currentToken[0] == ','){
                    getToken();
                    arith_expr();
                    if(currentToken[0] == '='){
                        getToken();
                        arith_expr();
                    }
                }
                if(currentToken[0] != ':') // :
                    error(":","proceed");
                else{
                    printf("Exit <declaration_stmt>\n");
                    getToken();
                }

            }
            else if(strcmp(currentToken,"=") == 0){ // =
                getToken();
                arith_expr();
                while(currentToken[0] == ','){
                    getToken();
                    arith_expr();
                    if(currentToken[0] == '='){
                        getToken();
                        arith_expr();
                    }
                }
                if(currentToken[0] != ':')
                    error(":","proceed");
                else{
                    printf("Exit <declaration_stmt>\n");
                    getToken();
                }
            }
            else
                error(": or , or assign_op",":");
        }
    }
}

void assignment_stmt(){
    if(strcmp(currentToken,"identifier") != 0)
        return;
    else{
        printf("Enter <assignment_stmt>\n");
        getToken();
        if(currentToken[0] != '=')
            error("=",":");
        else{
            getToken();
            arith_expr();
            if(currentToken[0] != ':')
                error(":","proceed");
            else{
                printf("Exit <assignment_stmt>\n");
                getToken();
            }
        }
    }
}

void arith_expr()
{
    arith_term();
    while (((currentToken[0] == '+') || (currentToken[0] == '-')) == true)
    {
        getToken();
        arith_term();
    }
}

void arith_term()
{
    arith_power();
    while (((currentToken[0] == '*') || (currentToken[0] == '/') || (currentToken[0] == '%') ||
            (currentToken[0] == '/' && currentToken[1] == '/')) == true)
    {
        getToken();
        arith_power();
    }
}

void arith_power()
{
    arith_factor();
    while ((currentToken[0] == '*' && currentToken[1] == '*') == true)
    {
        getToken();
        arith_factor();
    }
}

void arith_factor()
{
    if (strcmp(currentToken,"identifier")== 0 || strcmp(currentToken,"int_const")== 0 || strcmp(currentToken,"float_const")== 0
        || strcmp(currentToken,"char_const")== 0 || strcmp(currentToken,"str_const") == 0)
    { // id const
        getToken();
    }
    else if ((currentToken[0] == '(') == true)
    {
        getToken();
        arith_expr();

        if ((currentToken[0] == ')') == true)
        {
            getToken();
        }
        else
        {
            error(")","proceed");
        }
    }
    else
        error("id or const","proceed");
}

void iterative_stmt(){
    if(strcmp(currentToken,"for_keyword") != 0)
        return;
    else{
        printf("Enter <iterative_stmt>\n");
        getToken();
        if(currentToken[0] != '(') // (
            error("(","}");
        else{
            getToken();
            iterative_assign_stmt(); // assign_stmt
            if(currentToken[0] != ';') // ;
                error(";","}");
            else{
                getToken();
                condition();  // condition
                if(currentToken[0] != ';')  // ;
                    error(";","}");
                else{
                    getToken();
                    increment();   // increment
                    if(currentToken[0] != ')')
                        error(")","}");  // )
                    else{
                        getToken();
                        if(currentToken[0] != '{')  // {
                            error("{","}");
                        else{
                            getToken();
                            while(strcmp(currentToken,"scanf_keyword") == 0 || strcmp(currentToken,"printf_keyword") == 0 ||
                                  strcmp(currentToken,"data_type") == 0 || strcmp(currentToken,"identifier") == 0 ||
                                  strcmp(currentToken,"for_keyword") == 0 || strcmp(currentToken,"if_keyword") == 0){
                                    stmt();
                            }
                            if(currentToken[0] != '}')  // }
                                error("}","proceed");
                            else{
                                printf("Exit <iterative_stmt>\n");
                                getToken();
                            }
                        }

                    }
                }
            }
        }
    }
}

void iterative_assign_stmt(){
    if(strcmp(currentToken,"data_type") != 0)
        error("data_type",";");
    else{
        getToken();
        declaration_assign_stmt();
    }
}

void declaration_assign_stmt(){
    if(strcmp(currentToken,"identifier") != 0)
        error("identifier",";");
    else{
        getToken();
        if(currentToken[0] != '=')
            error("=",";");
        else{
            getToken();
            arith_expr();
        }
    }
}

void condition(){
    if(strcmp(currentToken,"identifier") != 0)
        error("identifier",";");
    else{
        getToken();
        if(currentToken[0] == '>' || currentToken[0] == '<' || strcmp(currentToken,"!=") == 0 ||
           strcmp(currentToken,"==") == 0 || strcmp(currentToken,">=") == 0 || strcmp(currentToken,"<=") == 0){
            getToken();
            if(strcmp(currentToken,"identifier") == 0 || strcmp(currentToken,"int_const") == 0 || strcmp(currentToken,"float_const") == 0 ||
               strcmp(currentToken,"char_const") == 0 || strcmp(currentToken,"str_const") == 0){
                   getToken();
            }
            else
                error("id or const",";");
        }
        else
            error("rel-op",";");
    }
}

void increment(){
    if(strcmp(currentToken,"identifier") == 0 || strcmp(currentToken,"++") == 0 || strcmp(currentToken,"--") == 0){
        getToken();
        if(strcmp(currentToken,"identifier") == 0 || strcmp(currentToken,"++") == 0 || strcmp(currentToken,"--") == 0){
            getToken();
        }
        else
            error("id or unary-op",")");
    }
    else
        error("id or unary-op",")");
}

void conditional_stmt(){
    if(strcmp(currentToken,"if_keyword") != 0)
        return;
    else{
        printf("Enter <conditional_stmt>\n");
        getToken();
        if(currentToken[0] !='(') // (
            error("(","}");
        else{
            getToken();
            bool_expr();  // boolean expr
            if(currentToken[0] != ')')  // )
                error(")","}");
            else{
                getToken();
                if(currentToken[0] != '{')  // {
                    error("{","}");
                else{
                    getToken();
                    while(strcmp(currentToken,"scanf_keyword") == 0 || strcmp(currentToken,"printf_keyword") == 0 ||
                          strcmp(currentToken,"data_type") == 0 || strcmp(currentToken,"identifier") == 0 ||
                          strcmp(currentToken,"for_keyword") == 0 || strcmp(currentToken,"if_keyword") == 0){
                            stmt();
                    }
                    if(currentToken[0] != '}')  // }
                        error("}","}");
                    else{
                        printf("Exit <conditional_stmt>\n");
                        getToken();
                        if(strcmp(currentToken,"else_keyword") == 0){ // else
                            printf("Enter <else_stmt>\n");
                            getToken();
                            if(currentToken[0] != '{') // {
                                error("{","}");
                            else{
                                getToken();
                                while(strcmp(currentToken,"scanf_keyword") == 0 || strcmp(currentToken,"printf_keyword") == 0 ||
                                      strcmp(currentToken,"data_type") == 0 || strcmp(currentToken,"identifier") == 0 ||
                                      strcmp(currentToken,"for_keyword") == 0 || strcmp(currentToken,"if_keyword") == 0){
                                        stmt();
                                }
                                if(currentToken[0] != '}')
                                    error("}","proceed");
                                else{
                                    printf("Exit <else_stmt>\n");
                                    getToken();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void bool_expr()
{
    bool_term();
    while (strcmp(currentToken,"or_op") == 0)
    {
        getToken();
        bool_term();
    }
}

void bool_term()
{
    bool_factor();
    while (strcmp(currentToken,"and_op") == 0)
    {
        getToken();
        bool_factor();
    }
}

void bool_factor()
{
    if (strcmp(currentToken,"not_op") == 0)
    {
        getToken();
        if (strcmp(currentToken,"identifier") == 0)
        {
            getToken();
        }
        else if ((currentToken[0] == '(') == true)
        {
            getToken();
            bool_expr();
            if ((currentToken[0] == ')') == true)
            {
                getToken();
            }
            else
                error(")","proceed");
        }
    }
    else if ((currentToken[0] == '(') == true)
    {
        getToken();
        bool_expr();
        if ((currentToken[0] == ')') == true)
        {
            getToken();
        }
    }
    else
    {
        rel_expr();
    }
}

void rel_expr(){
    if(strcmp(currentToken,"identifier") == 0 || strcmp(currentToken,"int_const") == 0 || strcmp(currentToken,"float_const") == 0 ||
       strcmp(currentToken,"char_const") == 0 || strcmp(currentToken,"str_const") == 0){ // id cnst
        getToken();
        if(strcmp(currentToken,"<") == 0 || strcmp(currentToken,">") == 0 || strcmp(currentToken,">=") == 0 ||
           strcmp(currentToken,"<=") == 0 || strcmp(currentToken,"==") == 0 || strcmp(currentToken,"!=") == 0){
            getToken();
            if(strcmp(currentToken,"identifier") == 0 || strcmp(currentToken,"int_const") == 0 || strcmp(currentToken,"float_const") == 0 ||
               strcmp(currentToken,"char_const") == 0 || strcmp(currentToken,"str_const") == 0){
                getToken();
            }
            else
                error("id or const","}");
           }
        else
            error("rel-op",")");
    }
    else
        error("id or const",")");
}

void rel_op(){
    if(strcmp(currentToken,"<") == 0 || strcmp(currentToken,">") == 0 || strcmp(currentToken,">=") == 0 ||
       strcmp(currentToken,"<=") == 0 || strcmp(currentToken,"==") == 0 || strcmp(currentToken,"!=") == 0)
        getToken();
    else{
        error("rel-op","}");
    }
}


void error(char *token, char *delimiter){
    printf("    ! error token: %s\n", currentToken);
    printf("    ! expected token: %s\n", token);

    if(strcmp(delimiter,";") == 0 || strcmp(delimiter,")") == 0){
        error_recovery(delimiter);
    }
    else if(strcmp(delimiter,"proceed") != 0){
        error_recovery(delimiter);
        getToken();
    }
    // if delimiter=proceed, as is
    // no getToken, return to stmt() then makakahanap ng next stmt
}

void error_recovery(char *delimiter){
    while(strcmp(currentToken,delimiter) != 0){
        getToken();
    }
}

bool isSeparator(char ch)
{
    char separatorList[] = {' ', '+', '-', '*', '/', '%', '>', '<', '!', '=',
                            '[', ']', '{', '}', '(', ')', ':', ';', ',', '\n', '\0'
                           };

    for (int i = 0; i < strlen(separatorList); i++)
    {
        if (separatorList[i] == ch)
            return (true);
    }

    return (false);
}

void identifyDelimiter(char ch)
{
    if (ch == '(')
    {
        token = "(";
    }
    else if (ch == ')')
    {
        token = ")";
    }
    else if (ch == '[')
    {
        token = "[";
    }
    else if (ch == ']')
    {
        token = "]";
    }
    else if (ch == '{')
    {
        token = "{";
    }
    else if (ch == '}')
    {
        token = "}";
    }
    else if (ch == ';')
    {
        token = ";";
    }
    else if (ch == ',')
    {
        token = ",";
    }
    else if (ch == ':')
    {
        token = ":";
    }
}

bool isOperator(char ch)
{
    char operatorList[] = {'=', '+', '-', '*', '/', '%', '!', '>', '<', '\0'};
    int i = 0;
    while (i < strlen(operatorList))
    {
        if (ch == operatorList[i])
        {
            return (true);
        }
        i++;
    }

    return (false);
}

void identifyOperator(char *subStr)
{
    // Arithmetic Operators

    if (subStr[0] == '+' && subStr[1] == '\0')
    {
        token = "+";
    }
    else if (subStr[0] == '-' && subStr[1] == '\0')
    {
        token = "-";
    }
    else if (subStr[0] == '/' && subStr[1] == '\0')
    {
        token = "/";
    }
    else if (subStr[0] == '*' && subStr[1] == '\0')
    {
        token = "*";
    }
    else if (subStr[0] == '%' && subStr[1] == '\0')
    {
        token = "%";
    }
    else if (subStr[0] == '*' && subStr[1] == '*' && subStr[2] == '\0')
    {
        token = "**";
    }
    else if (subStr[0] == '/' && subStr[1] == '/' && subStr[2] == '\0')
    {
        token = "//";
    }

    // Assignment Operators

    else if (subStr[0] == '=' && subStr[1] == '\0')
    {
        token = "=";
    }
    else if (subStr[0] == '+' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "+=";
    }
    else if (subStr[0] == '-' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "-=";
    }
    else if (subStr[0] == '*' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "*=";
    }
    else if (subStr[0] == '%' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "%=";
    }
    else if (subStr[0] == '/' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "/=";
    }
    else if (subStr[0] == '/' && subStr[1] == '/' && subStr[2] == '=' && subStr[3] == '\0')
    {
        token = "//=";
    }

    // Increment & Decrement

    else if (subStr[0] == '+' && subStr[1] == '+' && subStr[2] == '\0')
    {
        token = "++";
    }
    else if (subStr[0] == '-' && subStr[1] == '-' && subStr[2] == '\0')
    {
        token = "--";
    }

    // Boolean Relational

    else if (subStr[0] == '=' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "==";
    }
    else if (subStr[0] == '!' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "!=";
    }
    else if (subStr[0] == '>' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = ">=";
    }
    else if (subStr[0] == '<' && subStr[1] == '=' && subStr[2] == '\0')
    {
        token = "<=";
    }
    else if (subStr[0] == '>' && subStr[1] == '\0')
    {
        token = ">";
    }
    else if (subStr[0] == '<' && subStr[1] == '\0')
    {
        token = "<";
    }
    else
    {
        token = "invalid";
    }
}

bool isIdentifier(char *str)
{
    // first checkpoint
    // no alphabet = not qualified to be an identifier
    int alphacount = 0;
    for (int i = 0; i < strlen(str); i++)
    {
        if (isalpha(str[i]) != 0)
        {
            alphacount++;
        }
    }

    if (alphacount == 0)
    {
        return (false);
    }

    // second checkpoint
    // checks if each character in the str is an identifier element (a-zA-z,0-9,_)
    // if even 1 element is not an identifier element, then return true and tag it as an invalid id
    for (int i = 0; i < strlen(str); i++)
    {
        if (isIdentifierElement(str[i]) == false)
        {
            token = "invalid";
            return (true);
        }
    }

    // third checkpoint
    // checks if the first character is an alphabet
    // if not, then tag the str as an invalid identifier

    if (isalpha(str[0]) != 0)
    {
        token = "identifier";
        return (true);
    }
    token = "invalid";
    return (true);
}

bool isIdentifierElement(char ch)
{
    if (isalpha(ch) || isdigit(ch) || ch == '_')
    {
        return (true);
    }

    return (false);
}

bool isKeyword(char *subStr)
{
    if (subStr[0] == 'b' && subStr[1] == 'o' && subStr[2] == 'o' && subStr[3] == 'l' && subStr[4] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'c' && subStr[1] == 'u' && subStr[2] == 'e' && subStr[3] == 'r' && subStr[4] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'd' && subStr[1] == 'e' && subStr[2] == 'c' && subStr[3] == '\0')
    {
        token = "elif_keyword";
    }
    else if (subStr[0] == 'd' && subStr[1] == 'e' && subStr[2] == 's' && subStr[3] == 'c' &&
             subStr[4] == 'a' && subStr[5] == 'n' && subStr[6] == 's' && subStr[7] == 'o' && subStr[8] == '\0')
    {
        token = "break_keyword";
    }
    else if (subStr[0] == 'd' && subStr[1] == 'o' && subStr[2] == 'b' && subStr[3] == 'l' &&
             subStr[4] == 'e' && subStr[5] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'e' && subStr[1] == 'n' && subStr[2] == 't' && subStr[3] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'e' && subStr[1] == 's' && subStr[2] == 'c' && subStr[3] == 'a' && subStr[4] == 'n' &&
             subStr[5] == '\0')
    {
        token = "scanf_keyword";
    }
    else if (subStr[0] == 'f' && subStr[1] == 'l' && subStr[2] == 'o' && subStr[3] == 't' && subStr[4] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'h' && subStr[1] == 'a' && subStr[2] == 'c' && subStr[3] == 'e' &&
             subStr[4] == 'r' && subStr[5] == '\0')
    {
        token = "do_keyword";
    }
    else if (subStr[0] == 'i' && subStr[1] == 'm' && subStr[2] == 'p' && subStr[3] == 'r' && subStr[4] == 'i' &&
             subStr[5] == '\0')
    {
        token = "printf_keyword";
    }
    else if (subStr[0] == 'm' && subStr[1] == 'a' && subStr[2] == 's' && subStr[3] == '\0')
    {
        token = "else_keyword";
    }
    else if (subStr[0] == 'm' && subStr[1] == 'i' && subStr[2] == 'e' && subStr[3] == 'n' &&
             subStr[4] == 't' && subStr[5] == 'r' && subStr[6] == 'a' && subStr[7] == 's' && subStr[8] == '\0')
    {
        token = "while_keyword";
    }
    else if (subStr[0] == 'p' && subStr[1] == 'e' && subStr[2] == 'r' && subStr[3] == 's' && subStr[4] == 'o' &&
             subStr[5] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'p' && subStr[1] == 'o' && subStr[2] == 'r' && subStr[3] == '\0')
    {
        token = "for_keyword";
    }
    else if (subStr[0] == 'r' && subStr[1] == 'e' && subStr[2] == 't' && subStr[3] == 'o' &&
             subStr[4] == 'r' && subStr[5] == 'n' && subStr[6] == 'o' && subStr[7] == '\0')
    {
        token = "return_keyword";
    }
    else if (subStr[0] == 's' && subStr[1] == 'e' && subStr[2] == 'q' && subStr[3] == 'u' && subStr[4] == 'i' &&
             subStr[5] == 'r' && subStr[6] == '\0')
    {
        token = "continue_keyword";
    }
    else if (subStr[0] == 's' && subStr[1] == 'i' && subStr[2] == '\0')
    {
        token = "if_keyword";
    }
    else if (subStr[0] == 'v' && subStr[1] == 'a' && subStr[2] == 'c' && subStr[3] == 'i' && subStr[4] == 'o' &&
             subStr[5] == '\0')
    {
        token = "void_keyword";
    }
    else if (subStr[0] == 'v' && subStr[1] == 'a' && subStr[2] == 'm' && subStr[3] == 'o' && subStr[4] == 's' &&
             subStr[5] == '\0')
    {
        token = "goto_keyword";
    }

    // Boolean Logical
    else if (subStr[0] == 'y' && subStr[1] == '\0')
    {
        token = "and_op";
    }
    else if (subStr[0] == 'n' && subStr[1] == 'i' && subStr[2] == '\0')
    {
        token = "or_op";
    }
    else if (subStr[0] == 'n' && subStr[1] == 'o' && subStr[2] == '\0')
    {
        token = "not_op";
    }
    else
        return (false);

    return (true);
}

bool isReservedword(char *subStr)
{
    if (subStr[0] == 'f' && subStr[1] == 'a' && subStr[2] == 'l' && subStr[3] == 's' && subStr[4] == 'o' &&
            subStr[5] == '\0')
    {
        token = "false_reserved";
    }
    else if (subStr[0] == 'v' && subStr[1] == 'e' && subStr[2] == 'r' && subStr[3] == 'd' && subStr[4] == 'a' &&
             subStr[5] == 'd' && subStr[6] == '\0')
    {
        token = "true_reserved";
    }
    else
        return (false);

    return (true);
}

bool isNoiseword(char *subStr)
{
    if (subStr[0] == 'b' && subStr[1] == 'o' && subStr[2] == 'o' && subStr[3] == 'l' && subStr[4] == 'e' &&
            subStr[5] == 'a' && subStr[6] == 'n' && subStr[7] == 'o' && subStr[8] == '\0')
    {
        token = "data_type";
    }

    else if (subStr[0] == 'c' && subStr[1] == 'u' && subStr[2] == 'e' && subStr[3] == 'r' && subStr[4] == 'd' &&
             subStr[5] == 'a' && subStr[6] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'd' && subStr[1] == 'e' && subStr[2] == 'c' && subStr[3] == 'o' && subStr[4] == 'n' &&
             subStr[5] == 't' && subStr[6] == 'r' && subStr[7] == 'a' && subStr[8] == '\0')
    {
        token = "elif_noiseword";
    }
    else if (subStr[0] == 'e' && subStr[1] == 'n' && subStr[2] == 't' && subStr[3] == 'e' &&
             subStr[4] == 'r' && subStr[5] == 'o' && subStr[6] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'e' && subStr[1] == 's' && subStr[2] == 'c' && subStr[3] == 'a' &&
             subStr[4] == 'n' && subStr[5] == 'e' && subStr[6] == 'a' && subStr[7] == 'r' && subStr[8] == '\0')
    {
        token = "scanf_noiseword";
    }
    else if (subStr[0] == 'f' && subStr[1] == 'l' && subStr[2] == 'o' && subStr[3] == 't' && subStr[4] == 'a' &&
             subStr[5] == 'r' && subStr[6] == '\0')
    {
        token = "data_type";
    }
    else if (subStr[0] == 'i' && subStr[1] == 'm' && subStr[2] == 'p' && subStr[3] == 'r' &&
             subStr[4] == 'i' && subStr[5] == 'm' && subStr[6] == 'i' && subStr[7] == 'r' && subStr[8] == '\0')
    {
        token = "printf_noiseword";
    }
    else if (subStr[0] == 'p' && subStr[1] == 'e' && subStr[2] == 'r' &&
             subStr[3] == 's' && subStr[4] == 'o' && subStr[5] == 'n' && subStr[6] == 'a' &&
             subStr[7] == 'j' && subStr[8] == 'e' && subStr[9] == '\0')
    {
        token = "data_type";
    }
    else
        return (false);

    return (true);
}

bool isIntegerLiteral(char *str)
{
    for (int i = 0; i < strlen(str); i++)
    {
        if (isdigit(str[i]) == 0)
            return (false);
    }

    token = "int_const";
    return (true);
}

bool isFloatLiteral(char *str)
{
    for (int i = 0; i < strlen(str); i++)
    {
        if (isdigit(str[i]) == 0 && str[i] != '.')
            return (false);
    }

    int count = 0;

    for (int i = 0; i < strlen(str); i++)
    {
        if (str[i] == '.')
            count++;
    }

    if (count > 1)
    {
        token = "invalid";
    }
    else
    {
        token = "float_const";
    }

    return (true);
    /*
        if a character in the substring is neither a digit nor a '.', then return false
        if the first loop ends w/o returning, then the str contains only numeric values and decimal
    */
}
